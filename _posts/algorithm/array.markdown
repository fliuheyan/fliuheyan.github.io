## Array

### 2. Add two numbers 
1. 有一个预设头节点，然后将prev和current都指向这个预设节点，
这样不用在while循环之前去做head节点的特殊处理.
在while当中`current.next`
返回`prev.next`即为头节点

### 121. Best time to buy stock
1. 暴力算法：双for loop
2. 记录一个minPrice，这样只用loop一遍，循环的时候只要比较当前值和最小值> max就行.
唯一需要注意的是minPrice要初始化为Integer.MAX_VALUE.

### 122. Best time to buy stock 2
1. 一遍loop，找到最小拐点(当前值小于前一个和后一个值),和最大拐点(当前值大于前一个和后一个值).
同时判断当前值是否为第一个和最后一个. 当前数组size <= 1，说明无法卖股票，收益0.

### 123. Best Time to Buy and Sell Stock 3.
1. 投机方法，根据stock 2 取出所有的收益次数，取最大的两次
2. 背包问题
最多买两次，卖两次。所以这个问题可以转化为，四次操作背包最多装多少。

3. 循环两遍，从左到右一遍，从右到左一遍. 
第一遍求出从0-n当中第n天交易一次的最大收益，记录到数组f[]当中
第二遍从右到左，从n-1到0，当次为i,这样交易两次的最大收益就是f[i],加上后面一次交易的收益
* 决策树
    * 每天的选择为买入，卖出，不动(不买或者不卖)三种
    * 定义三个变量，分辨为index数组下标(当前天数)，status 0没买，1买入, k表示已经交易了几次
    * 当status=0,两种选择买入，不动
    * 当status=1,两种选择卖出，不动
    * 这样问题就转换为计算带权路径最大值
